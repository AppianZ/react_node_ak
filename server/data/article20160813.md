## 正则规范
正则表达式的英文是regular expression简称regex。
正则表达式就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个**“规则字符串”**，并让计算机用这个**规则**去检索符合规则的文本。

正则表达式主要有两个派别，一个是POSIX标准，使用这个标准的主要是linux系列的系统里的工具比如sed、awk等等；
还有一个是PCRE，这个表达式在编程语言里运用很广泛，比如php、java都是用PCRE，PCRE的功能比POSIX强很多。js就是用的PCRE。
 
## 用JS创建第一个正则
1.利用RegExp
`new RegExp('expression' [, options])`

2.利用反斜杠
`/expression/[options]`

> options的取值有以下两种：
> `i`，忽略大小写
> `g`，匹配全局，可能有多个匹配结果


## 正则学习正式开始
一个简单的正则表达式`expression`可以是最普通的字符串，举一个最简单的例子，abc是一个字符串，我们认为**abc**就是我们的**规则**，那么，正则就可以写成 `/abc/`。
当然实际场景不可能这么简单，实际场景可能更加复杂，下面将会慢慢介绍具体的定义**规则**的用法。

###  . 的用法
如果要匹配 aXb 这样的字符串，其中 X 表示可以是**任意一个字符** ，注意是，**一个字符**，那么可以写成

```js
/a.b/

/a.b/.test('aHb')  ---  true
/a.b/.test('aHHb')  ---  false
```

> 中间的 . 表示可以匹配任意一个字符

###  * 的用法
```js
/a*b/

/a*b/.test('b')  ---  true
/a*b/.test('ab')  ---  true
/a*b/.test('aaab')  ---  true
```

> 中间的 * 表示把星号前的字符匹配0次或多次

###  + 的用法
```js
/a+b/

/a+b/.test('b')  ---  false
/a+b/.test('ab')  ---  true
/a+b/.test('aaab')  ---  true
```

> + 表示前面的字符匹配1次或多次，这个表达式和 /aa*b/ 是完全一样的

###  ? 的用法
```js
/a?b/

/a?b/.test('b')  ---  true
/a?b/.test('ab')  ---  true
/a?b/.test('aaab')  ---  false
```

> ? 表示前面的字符匹配0次或1次

###  *、+ 和 ? 的匹配属于贪婪模式
比如需要用 `/a.*b/` 去匹配 `abcccccccbcc` 的话，从第一个字母看起来
这个表达式可以匹配 `ab` 和 `abcccccccb`， 那到底是匹配哪个？

“贪婪模式” 的意思就是，会**尽可能多的匹配**。
正则中的  `*` 是符合贪婪模式的，所以它会匹配到后者，因为后者的字符串更长.

```js
'abcccccccbcc'.replace(/a.*b/, 'Q')   ---  "Qcc"
'abcccccccb' 被匹配中了, 并 replace 成了 Q
```

### 如何将贪婪模式转为非贪婪模式？
“非贪婪模式” 的意思就是，会**尽可能少的匹配**。
做法就是在 `*`、`+`、`?` 的后面再加一个问号

比如需要用 `/a.*?b/` 去匹配 `abcccccccbcc` 的话，从第一个字母看起来
这个表达式可以匹配 `ab` 和 `abcccccccb`， 那到底是匹配哪个？
这次，显然是匹配到前者。

```js
'abcccccccbcc'.replace(/a.*?b/, 'Q')   ---  "Qcccccccbcc"
'ab' 被匹配中了, 并 replace 成了 Q
```

### * 和 + 匹配的字符可以是无穷个，如何指定匹配次数？
`*` 和 `+` 匹配的字符个数没有上限，但是可以通过`{}`来指定匹配次数
`/a{5}/`
> ↑↑↑ 把a匹配5次，效果和和/aaaaa/是完全一样的。

`/a{1,6}/`
> ↑↑↑ 把 a 匹配1~6次，可以匹配a、aa、aaa、aaaa、aaaaa和aaaaaa。

`/a{3,}/`
> ↑↑↑ 把a匹配 ≥ 3 次，可以匹配aaa、aaaaaaaaaa等等。效果和  /aaaa*/  或者  /aaa+/  完全一样。

## 如何指定开始匹配的位置？
我们之前讲的正则匹配都是从任意位置上开始匹配的。
比如`/ab+c/`表达式可以匹配“abbc1111111111”这个字符串，也可以匹配“111111abbcefg”这个字符串，**匹配规则的位置可以在字符串的任意位置**。

```js
/ab+c/.test('abbc1111111111')  ---  true
/ab+c/.test('111111abbcefg')  ---  true
```

那如果我要设置【**以某某规则开头**】的规则，如何设置？
答案是: **使用 ^**
那如果我要设置【**以某某规则结尾**】的规则，如何设置？
答案是: **使用 $**

### 使用 ^ 设置【以某某规则开头】的规则
```js
/^ab+c/.test('abbc1111111111')  ---  true
/^ab+c/.test('111111abbcefg')  --- false
```

^ 限制了正则匹配，必须从字符串开头开始，这样的话可以匹配“abbc1111111111”，但不能匹配“111111abbcefg”。


### 使用 $ 设置【以某某规则结尾】的规则
还有限制匹配到字符串末尾：
```js
/ab+c$/.test('abbc1111111111')  ---  false
/ab+c$/.test('111111abbcefg')  --- false
/ab+c$/.test('111111abbc')  --- true
```
这样可以匹配“111111abbc”，不能匹配“111111abbcefg” 或者 “abbc1111111111”

### 同时使用 $ 和 ^ 
把^和$一起用的话就可以限制整个字符串都要符合正则表达式

```js
/^ab+c$/.test('abbc1111111111')  ---  false
/^ab+c$/.test('111111abbcefg')  --- false
/^ab+c$/.test('abbbbbbbbc')  --- true
```
这样可以匹配“abbc”、“abbbbbc”，而不能匹配“abbc1111111111” 和 “111111abbcefg” 这样的字符串了。

## 利用 [] 指定一个字符的匹配规则
我们可以利用 [] 指定一个字符的匹配规则，记住！！ [] 只占一个字符的位子！！
但是这个位子上的字符匹配的可能性，可以在 [] 中随意指定匹配的范围。

### 如果要匹配某个位子上多个可能出现的字符
指定 a 和 c 之间，只能出现 b 或 B
```js
/a[bB]c/.test('abc')  --- true
/a[bB]c/.test('aBc')  --- true
/a[bB]c/.test('abbc') --- false
/a[bB]c/.test('aac')  --- false
```

### 如果要匹配某个位子上多个可能出现的数字
```js
/a[0-9]c/.test('a1c')  --- true
/a[0-9]c/.test('a11c')  --- false
/a[0-9]c/.test('abc') --- false
```

### [] 所匹配到的规则
上文中 `[0-9]` 表示可以**匹配一个一位整数**，这个是和字符编码有关的。0的编码是48，1的编码是49，以此类推，9的编码是57，所以0-9的编码，正好是连续的编码，所以可以用0-9表示匹配一个数字。
`/a[0-9]c/`就可以匹配a0c、a1c、......  、a9c

方括号里面也可以多种方式混合使用
```js
/a[bB0-9]c/.test('a1c')  --- true
/a[bB0-9]c/.test('abc') --- true
```
`/a[bB0-9]c/`就可以匹配abc、aBc和a0c、a1c、......  、a9c

### 在 [] 中使用 ^，能对 [] 中的规则取反
如果在方括号里面加上^的话，就表示匹配 “**所有不包含在方括号内的字符**”
```js
/a[^0-9]c/.test('a1c')  --- false
/a[^0-9]c/.test('abc') --- true
/a[^0-9]c/.test('a=c') --- true
```
`/a[^0-9]c/` ，表示匹配一个非数字，比如abc、a=c ...... ，但是不能匹配a0c、a1c、......  、a9c

### 如何指定匹配多个符合 [] 规则的字符
>  因为[]指定了一个字符的规则，如果想要多个符合[]内规则的字符，只需要在 [] 后面跟一个 + (匹配1个或多个)， 或跟上 * (匹配0个或多个)
> 也可以在 [] 后面跟上 {} 来指定个数， 如 `[0-9]{2, 6}` 表示匹配2~6个数字

## 利用 | 指定匹配多个字符串
`|` 相当于是 “**或**” 的意思，常用场景比如匹配可能出现的文件后缀
```js
/doc|xls|ppt/  ---  匹配doc xls ppt
/html|css|js/  ---  匹配html css js
```

### | 的优先级很低很低
`|` 的优先级比“**连接**”（就是字符串）低，如要在正则的字符串里使用 `|` 的话要加括号，提高优先级。

比如要匹配
wow, he is good  或者  wow, she is good.
最好这样写：
/wow, (she|he) is good./

## 使用 () 指定一个捕获组
括号除了能够提高匹配规则的优先级，还有一个作用，就是充当“捕获组”。
比如要匹配html的标签
`<body>what</body>`
可以这样写：
`/<([a-z]+)>.+<\/\1>/`

> `\1`，表示要完全匹配正则里第一个 () 里的规则的内容，
> 比如第一个 () 里的表达式匹配了body，那\1的部分也要完全匹配body
> 捕获组 () 最多9个， \1 ~ \9 分别与这9个 () 按顺序一一对应

### 在replace中使用捕获组
捕获组也可以在replace里面用。比如要把  `result = first + second - third` 里的变量名前面都加上`!` :
``` js
'result = first + second - third'.replace(/([a-z]+)/g, '!$1')

// "!result = !first + !second - !third"
```
在replace的第二个参数里，利用是`$1, $2, .....  $9` 引用捕获组。

但如果要把  `result = first + second - third` 里的变量名前面都加上`$` 怎么办呢？
``` js
'result = first + second - third'.replace(/([a-z]+)/g, '$$1')

// "$1 = $1 + $1 - $1"   这个结果不是我们想要的
```
所以规定，要在`$1, $2, .....  $9` 这样的关键字前面使用 `$`  这个字符本身的话，要用`$$`, 所以：
``` js
'result = first + second - third'.replace(/([a-z]+)/g, '$$$1')

// "$result = $first + $second - $third"
```
所以，上面的`$$$1`,  第1-2位是一个整体，表示一个普通的`$`字符串，第3-4位是一个整体，表示捕获组。

### 在exec中使用捕获组
使用正则的exec方法，可以取出exec中字符串匹配的部分
```js
/<([a-z]+)>/.exec("111<br>222<br>333")   

//["<br>", "br", index: 3, input: "111<br>222<br>333"]

/^(\w+)\.(jpg|jpeg|bmp|png|gif)$/i.exec('_dsa.png')

//["_dsa.png", "_dsa", "png", index: 0, input: "_dsa.png"]
```

返回值是一个数组。
数组第1个元素是匹配到的字符串结果，
数组第2个元素是匹配到的第1捕获组的内容，
数组第n个元素是匹配到的第(n - 1)捕获组的内容，
数组倒数第2个元素是匹配到的捕获组的起始下标，
数组倒数第1个元素是被exec执行匹配的字符串。

## 常用的简写
我们发现，实际场景中经常需要匹配数字，`[0-9]`、`[a-z]` 写起来太累了，有什么简写可以直接匹配到数字吗？或者还有哪些常用简写吗？ 有的有的。

### [0-9] 的简写 `\d`
[0-9]可以用来表示一个一位整数，它有自己的简写，`\d`。
如 `[0-9]{2, 6}` 表示匹配2~6个数字， 可以写成 `\d{2, 6}`
再如 `/a[bB0-9]c/` 可以写成 `\d{2, 6}`

### 空白符的简写 `\s`
`\s` 表示空白符，就是空格、tab这些不会显示出来的符号
```js
'H E L L O'.replace(/\s/g, '')  ---  "HELLO"
```

### 匹配_、数字或字母的简写 `\w`
`\w` 表示_、数字或字母
```js
'_123ABC..:‘'.replace(/\w/g, 'Q')  ---  "QQQQQQQ..:‘"
```

### 简写是区分大小写，那么大写啥意思？
> 如果把`\s`、`\d` 的字母换成大写就相当于是取反，
> 比如`\D` 表示匹配 “**不是数字的字符**”
> 比如`\W` 表示匹配 “**不是_、数字或字母的字符**”

```js
'_123ABC..:‘'.replace(/\w/g, 'Q')  ---  "QQQQQQQ..:‘"
'_123ABC..:‘'.replace(/\W/g, 'Q')  ---  "_123ABCQQQQ" 
```

## 使用正则关键字前，请使用转义
比如，现在需要写出js的变量命名规则：以`$`、`_` 或字母开头，后面跟上0个或多个`$`、`_`、字母或数字。
```js
/^[\$_a-zA-Z][\$_0-9a-zA-Z]*$/i
```
因为`$`字符在正则表达式里是个特殊字符，所以要表达“匹配$字符”的话就要把`$`字符转义，就是在$前面加一个`\`，变成`\$`
像`.`、`+`、`*`、`?`、`^`、`$`、`[`、`]`、`{`、`}` 等等这些关键字符号，如果要匹配这些字符就要转义。

- - - - --

## 小练习
①  编写一个正则表达式，判断一个文件名的后缀是不是doc、xls或ppt。

② 编写一个匹配坐标的正则表达式。
    一个坐标的形式是(a,b)，其中a和b都是任意位数的数字，也可能为负数。

③ 编写一个匹配IP地址的正则表达式。
    IP地址的形式为a.b.c.d，其中a,b,c,d都是一个0到255之间的数字（包含0和255，如果有多个0的话也算0，比如000和00都可以）

④ 编写一个匹配图片文件名的正则。
    图片文件名的形式为： 名称.后缀名，其中名称可以是任意的字符串，但不能为空；后缀名可以是jpg,jpeg,bmp,png和gif，不区分大小写

⑤ 承接上题，把匹配的图片文件名里的“名称”和“后缀名”部分取出来。比如abc.jpeg的名称和后缀名分别为“abc”和“jpeg”（提示：使用exec方法）

⑥ 承接上题，把匹配的图片文件名替换为“File XXX is a YYY file.”的形式，其中XXX是“名称”部分，YYY是“后缀名”部分。

- - - - --
![](https://ohovav7hg.qnssl.com/articlecover17.png)
## 公布答案
①  编写一个正则表达式，判断一个文件名的后缀是不是doc、xls或ppt。
```js
/^\w+\.(doc|xls|ppt)$/.test('_dsa.xls')
```

② 编写一个匹配坐标的正则表达式。
    一个坐标的形式是(a,b)，其中a和b都是任意位数的数字，也可能为负数。
```js
/^\(-?\d+,-?\d+\)$/.test('(23,-4324)')
```

③ 编写一个匹配IP地址的正则表达式。
    IP地址的形式为a.b.c.d，其中a,b,c,d都是一个0到255之间的数字（包含0和255，如果有多个0的话也算0，比如000和00都可以）。
```js
/^(\d{1,2})|([01]\d{0,2})|([2][0-4]\d)|(25[0-5])$/.test(256)

/^((\d{1,2}\.)|([01]\d{0,2}\.)|([2][0-4]\d\.)|(25[0-5]\.)){3}((\d{1,2})|([01]\d{0,2})|([2][0-4]\d)|(25[0-5]))$/.test('25.244.244.000')
```

④ 编写一个匹配图片文件名的正则。
    图片文件名的形式为： 名称.后缀名，其中名称可以是任意的字符串，但不能为空；后缀名可以是jpg,jpeg,bmp,png和gif，不区分大小写
```js
/^\w+\.(jpg|jpeg|bmp|png|gif)$/i.test('_dsa.Png')
```

⑤ 承接上题，把匹配的图片文件名里的“名称”和“后缀名”部分取出来。比如abc.jpeg的名称和后缀名分别为“abc”和“jpeg”
```js
/^(\w+)\.(jpg|jpeg|bmp|png|gif)$/i.exec('_dsa.png')
```

⑥ 承接上题，把匹配的图片文件名替换为“File XXX is a YYY file.”的形式，其中XXX是“名称”部分，YYY是“后缀名”部分。
    比如abc.jpeg会替换为“File abc is a jpeg file”。
```js
'_dsa.png'.replace(/^(\w+)\.(jpg|jpeg|bmp|png|gif)$/i,"File $1 is a $2 file.")
```

