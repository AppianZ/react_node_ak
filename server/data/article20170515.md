## 一句话: HTTPS = HTTP + SSL
### 相同点
    大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。而 HTTPS 和 HTTP 唯一不同的只是一个协议头(https)的说明，其他都是一样的。

### 不同点
|不同点|http|https|
|:---:|:---:|:---:|
|URL|http:// 开头| https:// 开头|
|安全性|不安全的|安全|
|标准端口|80|443|
| OSI 网络模型|工作于应用层|工作在传输层|
|数据加密|无需加密|对传输的数据进行加密|
|证书|无需证书|需要认证证书|


### 非对称加密 
**基本特性**
![](https://ohovav7hg.qnssl.com/2017-02-10-11-38-14.jpg)

公钥和私钥都可以用来加密和解密，公钥加密的数据必须用私钥来解密，私钥加密的数据必须用公钥来解密。

**非对称加密具有防篡改，防抵赖，验证的特性**
**防篡改**：即A用自己的私钥加密的信息，仅有A的公钥可以解密，而加密的信息如果被修改，则不能用A的公钥进行解密了，假如有人想模仿A对数据进行加密，没有A的私钥是做不到的，所以如果有人没有A的私钥却想篡改A加密过的数据，那其他人就无法用A的公钥解密了，这就是防篡改。
![](https://ohovav7hg.qnssl.com/2017-02-10-11-38-45.jpg)

![](https://ohovav7hg.qnssl.com/2017-02-10-11-40-26.jpg)

**防抵赖**：假如A用自己私钥加密过的数据，有天A不承认这个数据是他的，但别人拿着A的公钥却可以解密这个数据，那说明这个数据一定是A的，因为非对称加密的特性决定了只有私钥加密过的数据公钥才能解密，而私钥只有A有，所以A无法抵赖。
![](https://ohovav7hg.qnssl.com/2017-02-10-11-40-52.jpg)

**验证**：B有A的公钥，B发送一句hello给A，A用自己的私钥加密了hello发回给B，B用A的公钥解密了数据发现是自己之前发给A的hello，证明对面那个人是A。
![](https://ohovav7hg.qnssl.com/2017-02-10-11-41-14.jpg)

以上都基于一个假设是，私钥仅有A一个人有

### 数字签名
**原理**
A对发送原文生成md5摘要，然后用自己的私钥对摘要加密得到签名，签名随原文一起发送给B，原文可以是明文，B用公钥解密签名得到摘要，B自己对原文md5，比较是否和摘要一致，如果一致，证明原文是A发过来的，并且是完整的，即数字签名的主要作用是校验数据完整性和验证发送者身份。
![](https://ohovav7hg.qnssl.com/2017-02-10-11-57-29.jpg)

但是，A直接用私钥加密原文发给B，如果B解密成功，不也可以证明数据完整性和验证发送者身份？
因为**计算原文md5的时间+对摘要进行加密的时间小于对原文进行加密的时间**


### 数字证书
**原理**
![](https://ohovav7hg.qnssl.com/2017-02-10-12-13-39.jpg)

以上的数据完整性校验也好，身份验证也好，防篡改防抵赖也好，都基于一个假设是，A的私钥不泄漏，公钥是属于A的，前者，作为企业注重安全，比较能够保证，而后者，作为用户，可能存在公钥被攻击者替换的情况，然后攻击者用自己的私钥伪装企业和用户进行通信，那这种时候怎么办？
这里的关键问题在于，你手里的公钥是否值得你信任？只有你信任你手里的公钥是A的，然后才可以信任用公钥解密的数据是A的且完整的，但假如你手里的公钥就不是A的，那信任也就谈不上了。为了解决这个问题，我们需要一个第三方的权威机构，A将自己的公钥及一些摘要算法交给这个机构，机构根据A的公钥和摘要算法(这些东西的集合我们成为P)，对P进行签名得到S，P和S在一起就得到一个证书，然后用户可以根据这个证书得到A的公钥，从而对A的内容进行解密。
那你会说，这个证书也还是会有被伪造的可能性啊，的确，但解密证书的公钥是CA给浏览器/操作系统厂商的，被内置在浏览器/操作系统的，全世界就这几个CA，相当于你信任浏览器和操作系统了，所以你也信任这个解密证书的公钥，这个信任，是整个安全的基石。

**证书解决了什么问题？**
证书解决了确认对方身份的问题，即有了证书，你可以确认和你通信的是你期望的对象。

### HTTPS
**原理**
服务器A会用自己的私钥加密网页内容，并联同申请的证书一起发给用户，用户拿到证书后，应用程序(可能是浏览器)拿到证书后，通过操作系统的证书管理器知道有哪些CA，并用证书对应CA的公钥解 密证书，得到服务器A的公钥，以及确认这个证书是否颁发给这个域名。假如一个网站用了其他网站的证书，浏览器也会发现证书上颁发的域名和这个网站不一致从而报警。也可能这个证书就不是由信任机构颁发的，浏览器也会报警

![](https://ohovav7hg.qnssl.com/2017-02-10-17-25-44.jpg)

**整个流程**
1. 客户端发起请求，发送随机数和其他信息，包括客户端支持的SSL协议版本和支持的加密算法等，随机数用来生成会话密钥
2. 服务器生成随机数作为会话密钥，根据客户的支持的协议和加密算法选择合适的协议和加密算法，并发送证书给客户端
3. 客户端校验证书，校验成功后，客户生成一个对称密钥，用服务器的公钥加密对称密钥发送给服务器
4. 服务器解密得到对称密钥，并发送响应向客户端确认，握手完成
5. 正式通信


我们在导入一个证书，其实是导入了一个CA即可信任的机构，比如12306的证书/BurpSuite的证书，而不是导入了服务器发给你看的证书。


SSH协议的基本原理是对称加密和非对称加密的结合
**SSH协议握手的过程是**

![](https://ohovav7hg.qnssl.com/2017-02-10-17-36-53.jpg)

1. 客户端发起请求建立第一次连接
2. 服务端生成公钥和私钥，公钥发给客户端
3. 客户端拿到公钥后，把一个对称密钥加密发送给服务端
4. 服务端拿到加密数据，用私钥解密，得到对称密钥
5. 之后服务端用对称密钥加密数据，和客户端正式建立连接

### https握手

